// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protos.proto

#ifndef PROTOBUF_Protos_2eproto__INCLUDED
#define PROTOBUF_Protos_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace runtime {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Protos_2eproto();
void protobuf_AssignDesc_Protos_2eproto();
void protobuf_ShutdownFile_Protos_2eproto();

class FileSendProtos;
class FileSendComplete;

enum FileSendProtos_CompressType {
  FileSendProtos_CompressType_NO_COMPRESS = 0,
  FileSendProtos_CompressType_ZIP = 1
};
bool FileSendProtos_CompressType_IsValid(int value);
const FileSendProtos_CompressType FileSendProtos_CompressType_CompressType_MIN = FileSendProtos_CompressType_NO_COMPRESS;
const FileSendProtos_CompressType FileSendProtos_CompressType_CompressType_MAX = FileSendProtos_CompressType_ZIP;
const int FileSendProtos_CompressType_CompressType_ARRAYSIZE = FileSendProtos_CompressType_CompressType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FileSendProtos_CompressType_descriptor();
inline const ::std::string& FileSendProtos_CompressType_Name(FileSendProtos_CompressType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FileSendProtos_CompressType_descriptor(), value);
}
inline bool FileSendProtos_CompressType_Parse(
    const ::std::string& name, FileSendProtos_CompressType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FileSendProtos_CompressType>(
    FileSendProtos_CompressType_descriptor(), name, value);
}
enum FileSendProtos_VerifyMode {
  FileSendProtos_VerifyMode_NO_VERIFY = 0,
  FileSendProtos_VerifyMode_CRC = 1,
  FileSendProtos_VerifyMode_MD5 = 2
};
bool FileSendProtos_VerifyMode_IsValid(int value);
const FileSendProtos_VerifyMode FileSendProtos_VerifyMode_VerifyMode_MIN = FileSendProtos_VerifyMode_NO_VERIFY;
const FileSendProtos_VerifyMode FileSendProtos_VerifyMode_VerifyMode_MAX = FileSendProtos_VerifyMode_MD5;
const int FileSendProtos_VerifyMode_VerifyMode_ARRAYSIZE = FileSendProtos_VerifyMode_VerifyMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* FileSendProtos_VerifyMode_descriptor();
inline const ::std::string& FileSendProtos_VerifyMode_Name(FileSendProtos_VerifyMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    FileSendProtos_VerifyMode_descriptor(), value);
}
inline bool FileSendProtos_VerifyMode_Parse(
    const ::std::string& name, FileSendProtos_VerifyMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FileSendProtos_VerifyMode>(
    FileSendProtos_VerifyMode_descriptor(), name, value);
}
enum FileSendComplete_RESULT {
  FileSendComplete_RESULT_SUCCESS = 0,
  FileSendComplete_RESULT_FAILED_LOWDISKSPACE = 1
};
bool FileSendComplete_RESULT_IsValid(int value);
const FileSendComplete_RESULT FileSendComplete_RESULT_RESULT_MIN = FileSendComplete_RESULT_SUCCESS;
const FileSendComplete_RESULT FileSendComplete_RESULT_RESULT_MAX = FileSendComplete_RESULT_FAILED_LOWDISKSPACE;
const int FileSendComplete_RESULT_RESULT_ARRAYSIZE = FileSendComplete_RESULT_RESULT_MAX + 1;

const ::google::protobuf::EnumDescriptor* FileSendComplete_RESULT_descriptor();
inline const ::std::string& FileSendComplete_RESULT_Name(FileSendComplete_RESULT value) {
  return ::google::protobuf::internal::NameOfEnum(
    FileSendComplete_RESULT_descriptor(), value);
}
inline bool FileSendComplete_RESULT_Parse(
    const ::std::string& name, FileSendComplete_RESULT* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FileSendComplete_RESULT>(
    FileSendComplete_RESULT_descriptor(), name, value);
}
// ===================================================================

class FileSendProtos : public ::google::protobuf::Message {
 public:
  FileSendProtos();
  virtual ~FileSendProtos();

  FileSendProtos(const FileSendProtos& from);

  inline FileSendProtos& operator=(const FileSendProtos& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FileSendProtos& default_instance();

  void Swap(FileSendProtos* other);

  // implements Message ----------------------------------------------

  FileSendProtos* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileSendProtos& from);
  void MergeFrom(const FileSendProtos& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef FileSendProtos_CompressType CompressType;
  static const CompressType NO_COMPRESS = FileSendProtos_CompressType_NO_COMPRESS;
  static const CompressType ZIP = FileSendProtos_CompressType_ZIP;
  static inline bool CompressType_IsValid(int value) {
    return FileSendProtos_CompressType_IsValid(value);
  }
  static const CompressType CompressType_MIN =
    FileSendProtos_CompressType_CompressType_MIN;
  static const CompressType CompressType_MAX =
    FileSendProtos_CompressType_CompressType_MAX;
  static const int CompressType_ARRAYSIZE =
    FileSendProtos_CompressType_CompressType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CompressType_descriptor() {
    return FileSendProtos_CompressType_descriptor();
  }
  static inline const ::std::string& CompressType_Name(CompressType value) {
    return FileSendProtos_CompressType_Name(value);
  }
  static inline bool CompressType_Parse(const ::std::string& name,
      CompressType* value) {
    return FileSendProtos_CompressType_Parse(name, value);
  }

  typedef FileSendProtos_VerifyMode VerifyMode;
  static const VerifyMode NO_VERIFY = FileSendProtos_VerifyMode_NO_VERIFY;
  static const VerifyMode CRC = FileSendProtos_VerifyMode_CRC;
  static const VerifyMode MD5 = FileSendProtos_VerifyMode_MD5;
  static inline bool VerifyMode_IsValid(int value) {
    return FileSendProtos_VerifyMode_IsValid(value);
  }
  static const VerifyMode VerifyMode_MIN =
    FileSendProtos_VerifyMode_VerifyMode_MIN;
  static const VerifyMode VerifyMode_MAX =
    FileSendProtos_VerifyMode_VerifyMode_MAX;
  static const int VerifyMode_ARRAYSIZE =
    FileSendProtos_VerifyMode_VerifyMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  VerifyMode_descriptor() {
    return FileSendProtos_VerifyMode_descriptor();
  }
  static inline const ::std::string& VerifyMode_Name(VerifyMode value) {
    return FileSendProtos_VerifyMode_Name(value);
  }
  static inline bool VerifyMode_Parse(const ::std::string& name,
      VerifyMode* value) {
    return FileSendProtos_VerifyMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string filename = 1;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 1;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // required uint64 modified_time = 2;
  inline bool has_modified_time() const;
  inline void clear_modified_time();
  static const int kModifiedTimeFieldNumber = 2;
  inline ::google::protobuf::uint64 modified_time() const;
  inline void set_modified_time(::google::protobuf::uint64 value);

  // required uint64 content_size = 3;
  inline bool has_content_size() const;
  inline void clear_content_size();
  static const int kContentSizeFieldNumber = 3;
  inline ::google::protobuf::uint64 content_size() const;
  inline void set_content_size(::google::protobuf::uint64 value);

  // required .runtime.FileSendProtos.CompressType compress_type = 4;
  inline bool has_compress_type() const;
  inline void clear_compress_type();
  static const int kCompressTypeFieldNumber = 4;
  inline ::runtime::FileSendProtos_CompressType compress_type() const;
  inline void set_compress_type(::runtime::FileSendProtos_CompressType value);

  // required .runtime.FileSendProtos.VerifyMode verify_mode = 5;
  inline bool has_verify_mode() const;
  inline void clear_verify_mode();
  static const int kVerifyModeFieldNumber = 5;
  inline ::runtime::FileSendProtos_VerifyMode verify_mode() const;
  inline void set_verify_mode(::runtime::FileSendProtos_VerifyMode value);

  // required string verify_sign = 6;
  inline bool has_verify_sign() const;
  inline void clear_verify_sign();
  static const int kVerifySignFieldNumber = 6;
  inline const ::std::string& verify_sign() const;
  inline void set_verify_sign(const ::std::string& value);
  inline void set_verify_sign(const char* value);
  inline void set_verify_sign(const char* value, size_t size);
  inline ::std::string* mutable_verify_sign();
  inline ::std::string* release_verify_sign();
  inline void set_allocated_verify_sign(::std::string* verify_sign);

  // @@protoc_insertion_point(class_scope:runtime.FileSendProtos)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_modified_time();
  inline void clear_has_modified_time();
  inline void set_has_content_size();
  inline void clear_has_content_size();
  inline void set_has_compress_type();
  inline void clear_has_compress_type();
  inline void set_has_verify_mode();
  inline void clear_has_verify_mode();
  inline void set_has_verify_sign();
  inline void clear_has_verify_sign();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* filename_;
  ::google::protobuf::uint64 modified_time_;
  ::google::protobuf::uint64 content_size_;
  int compress_type_;
  int verify_mode_;
  ::std::string* verify_sign_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_Protos_2eproto();
  friend void protobuf_AssignDesc_Protos_2eproto();
  friend void protobuf_ShutdownFile_Protos_2eproto();

  void InitAsDefaultInstance();
  static FileSendProtos* default_instance_;
};
// -------------------------------------------------------------------

class FileSendComplete : public ::google::protobuf::Message {
 public:
  FileSendComplete();
  virtual ~FileSendComplete();

  FileSendComplete(const FileSendComplete& from);

  inline FileSendComplete& operator=(const FileSendComplete& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FileSendComplete& default_instance();

  void Swap(FileSendComplete* other);

  // implements Message ----------------------------------------------

  FileSendComplete* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileSendComplete& from);
  void MergeFrom(const FileSendComplete& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef FileSendComplete_RESULT RESULT;
  static const RESULT SUCCESS = FileSendComplete_RESULT_SUCCESS;
  static const RESULT FAILED_LOWDISKSPACE = FileSendComplete_RESULT_FAILED_LOWDISKSPACE;
  static inline bool RESULT_IsValid(int value) {
    return FileSendComplete_RESULT_IsValid(value);
  }
  static const RESULT RESULT_MIN =
    FileSendComplete_RESULT_RESULT_MIN;
  static const RESULT RESULT_MAX =
    FileSendComplete_RESULT_RESULT_MAX;
  static const int RESULT_ARRAYSIZE =
    FileSendComplete_RESULT_RESULT_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RESULT_descriptor() {
    return FileSendComplete_RESULT_descriptor();
  }
  static inline const ::std::string& RESULT_Name(RESULT value) {
    return FileSendComplete_RESULT_Name(value);
  }
  static inline bool RESULT_Parse(const ::std::string& name,
      RESULT* value) {
    return FileSendComplete_RESULT_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string filename = 1;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 1;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // required .runtime.FileSendComplete.RESULT result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::runtime::FileSendComplete_RESULT result() const;
  inline void set_result(::runtime::FileSendComplete_RESULT value);

  // @@protoc_insertion_point(class_scope:runtime.FileSendComplete)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* filename_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Protos_2eproto();
  friend void protobuf_AssignDesc_Protos_2eproto();
  friend void protobuf_ShutdownFile_Protos_2eproto();

  void InitAsDefaultInstance();
  static FileSendComplete* default_instance_;
};
// ===================================================================


// ===================================================================

// FileSendProtos

// required string filename = 1;
inline bool FileSendProtos::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileSendProtos::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileSendProtos::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileSendProtos::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& FileSendProtos::filename() const {
  return *filename_;
}
inline void FileSendProtos::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void FileSendProtos::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void FileSendProtos::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileSendProtos::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* FileSendProtos::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FileSendProtos::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 modified_time = 2;
inline bool FileSendProtos::has_modified_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileSendProtos::set_has_modified_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileSendProtos::clear_has_modified_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileSendProtos::clear_modified_time() {
  modified_time_ = GOOGLE_ULONGLONG(0);
  clear_has_modified_time();
}
inline ::google::protobuf::uint64 FileSendProtos::modified_time() const {
  return modified_time_;
}
inline void FileSendProtos::set_modified_time(::google::protobuf::uint64 value) {
  set_has_modified_time();
  modified_time_ = value;
}

// required uint64 content_size = 3;
inline bool FileSendProtos::has_content_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FileSendProtos::set_has_content_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FileSendProtos::clear_has_content_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FileSendProtos::clear_content_size() {
  content_size_ = GOOGLE_ULONGLONG(0);
  clear_has_content_size();
}
inline ::google::protobuf::uint64 FileSendProtos::content_size() const {
  return content_size_;
}
inline void FileSendProtos::set_content_size(::google::protobuf::uint64 value) {
  set_has_content_size();
  content_size_ = value;
}

// required .runtime.FileSendProtos.CompressType compress_type = 4;
inline bool FileSendProtos::has_compress_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FileSendProtos::set_has_compress_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FileSendProtos::clear_has_compress_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FileSendProtos::clear_compress_type() {
  compress_type_ = 0;
  clear_has_compress_type();
}
inline ::runtime::FileSendProtos_CompressType FileSendProtos::compress_type() const {
  return static_cast< ::runtime::FileSendProtos_CompressType >(compress_type_);
}
inline void FileSendProtos::set_compress_type(::runtime::FileSendProtos_CompressType value) {
  assert(::runtime::FileSendProtos_CompressType_IsValid(value));
  set_has_compress_type();
  compress_type_ = value;
}

// required .runtime.FileSendProtos.VerifyMode verify_mode = 5;
inline bool FileSendProtos::has_verify_mode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FileSendProtos::set_has_verify_mode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FileSendProtos::clear_has_verify_mode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FileSendProtos::clear_verify_mode() {
  verify_mode_ = 0;
  clear_has_verify_mode();
}
inline ::runtime::FileSendProtos_VerifyMode FileSendProtos::verify_mode() const {
  return static_cast< ::runtime::FileSendProtos_VerifyMode >(verify_mode_);
}
inline void FileSendProtos::set_verify_mode(::runtime::FileSendProtos_VerifyMode value) {
  assert(::runtime::FileSendProtos_VerifyMode_IsValid(value));
  set_has_verify_mode();
  verify_mode_ = value;
}

// required string verify_sign = 6;
inline bool FileSendProtos::has_verify_sign() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FileSendProtos::set_has_verify_sign() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FileSendProtos::clear_has_verify_sign() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FileSendProtos::clear_verify_sign() {
  if (verify_sign_ != &::google::protobuf::internal::kEmptyString) {
    verify_sign_->clear();
  }
  clear_has_verify_sign();
}
inline const ::std::string& FileSendProtos::verify_sign() const {
  return *verify_sign_;
}
inline void FileSendProtos::set_verify_sign(const ::std::string& value) {
  set_has_verify_sign();
  if (verify_sign_ == &::google::protobuf::internal::kEmptyString) {
    verify_sign_ = new ::std::string;
  }
  verify_sign_->assign(value);
}
inline void FileSendProtos::set_verify_sign(const char* value) {
  set_has_verify_sign();
  if (verify_sign_ == &::google::protobuf::internal::kEmptyString) {
    verify_sign_ = new ::std::string;
  }
  verify_sign_->assign(value);
}
inline void FileSendProtos::set_verify_sign(const char* value, size_t size) {
  set_has_verify_sign();
  if (verify_sign_ == &::google::protobuf::internal::kEmptyString) {
    verify_sign_ = new ::std::string;
  }
  verify_sign_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileSendProtos::mutable_verify_sign() {
  set_has_verify_sign();
  if (verify_sign_ == &::google::protobuf::internal::kEmptyString) {
    verify_sign_ = new ::std::string;
  }
  return verify_sign_;
}
inline ::std::string* FileSendProtos::release_verify_sign() {
  clear_has_verify_sign();
  if (verify_sign_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = verify_sign_;
    verify_sign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FileSendProtos::set_allocated_verify_sign(::std::string* verify_sign) {
  if (verify_sign_ != &::google::protobuf::internal::kEmptyString) {
    delete verify_sign_;
  }
  if (verify_sign) {
    set_has_verify_sign();
    verify_sign_ = verify_sign;
  } else {
    clear_has_verify_sign();
    verify_sign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FileSendComplete

// required string filename = 1;
inline bool FileSendComplete::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileSendComplete::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileSendComplete::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileSendComplete::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& FileSendComplete::filename() const {
  return *filename_;
}
inline void FileSendComplete::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void FileSendComplete::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void FileSendComplete::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileSendComplete::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* FileSendComplete::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FileSendComplete::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .runtime.FileSendComplete.RESULT result = 2;
inline bool FileSendComplete::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileSendComplete::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileSendComplete::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileSendComplete::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::runtime::FileSendComplete_RESULT FileSendComplete::result() const {
  return static_cast< ::runtime::FileSendComplete_RESULT >(result_);
}
inline void FileSendComplete::set_result(::runtime::FileSendComplete_RESULT value) {
  assert(::runtime::FileSendComplete_RESULT_IsValid(value));
  set_has_result();
  result_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace runtime

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::runtime::FileSendProtos_CompressType>() {
  return ::runtime::FileSendProtos_CompressType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::runtime::FileSendProtos_VerifyMode>() {
  return ::runtime::FileSendProtos_VerifyMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::runtime::FileSendComplete_RESULT>() {
  return ::runtime::FileSendComplete_RESULT_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Protos_2eproto__INCLUDED
